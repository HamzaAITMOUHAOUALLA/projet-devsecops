# .github/workflows/security-scan.yml
# üõ°Ô∏è DevSecOps Security Scanning Pipeline - Enhanced Version

name: üîí Security Scanner

on:
  workflow_dispatch:
    inputs:
      target_repo:
        description: 'Repository URL to scan'
        required: true
        type: string
      scan_id:
        description: 'Unique scan identifier'
        required: true
        type: string
      callback_url:
        description: 'Callback URL for results'
        required: true
        type: string
      timestamp:
        description: 'Horodatage du d√©clenchement'
        required: false
      scan_depth:
        description: 'Niveau de scan (standard, deep)'
        required: false
        default: 'standard'
        type: choice
        options:
          - standard
          - deep

env:
  SCAN_ID: ${{ github.event.inputs.scan_id }}
  CALLBACK_URL: ${{ github.event.inputs.callback_url }}
  TARGET_REPO: ${{ github.event.inputs.target_repo }}
  SCAN_DEPTH: ${{ github.event.inputs.scan_depth }}
  SCAN_TIMESTAMP: ${{ github.event.inputs.timestamp }}

jobs:
  security-scan:
    name: üîç Security Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    outputs:
      scan-status: ${{ steps.final-status.outputs.status }}
      vulnerabilities-found: ${{ steps.process-results.outputs.total-vulnerabilities }}
      critical-count: ${{ steps.process-results.outputs.critical }}
      high-count: ${{ steps.process-results.outputs.high }}
      medium-count: ${{ steps.process-results.outputs.medium }}
      low-count: ${{ steps.process-results.outputs.low }}
      
    steps:
      - name: üìã Job Information
        run: |
          echo "üöÄ Starting Security Scan"
          echo "üì¶ Repository: ${{ env.TARGET_REPO }}"
          echo "üÜî Scan ID: ${{ env.SCAN_ID }}"
          echo "üìû Callback: ${{ env.CALLBACK_URL }}"
          echo "üîç Depth: ${{ env.SCAN_DEPTH }}"
          echo "‚è∞ Started: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

      - name: ‚ö° Setup Environment
        run: |
          echo "SCAN_START_TIME=$(date +%s)" >> $GITHUB_ENV
          echo "SCAN_TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV
          
          # Create results directory
          mkdir -p scan-results
          
          # Initialize counters
          echo "FILES_SCANNED=0" >> $GITHUB_ENV
          echo "TOTAL_VULNERABILITIES=0" >> $GITHUB_ENV
          echo "CRITICAL_COUNT=0" >> $GITHUB_ENV
          echo "HIGH_COUNT=0" >> $GITHUB_ENV
          echo "MEDIUM_COUNT=0" >> $GITHUB_ENV
          echo "LOW_COUNT=0" >> $GITHUB_ENV

      - name: üêç Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: üìÇ Clone Target Repository
        id: clone-repo
        run: |
          echo "üîÑ Cloning repository..."
          
          # Extract repo info from URL
          REPO_URL="${{ env.TARGET_REPO }}"
          REPO_NAME=$(echo $REPO_URL | sed 's/.*github\.com\///g' | sed 's/\.git$//g')
          REPO_DIR=$(echo $REPO_NAME | sed 's/.*\///g')
          
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "REPO_DIR=$REPO_DIR" >> $GITHUB_ENV
          
          # Clone with depth based on scan level
          CLONE_DEPTH=1
          if [ "${{ env.SCAN_DEPTH }}" = "deep" ]; then
            CLONE_DEPTH=50
          elif [ "${{ env.SCAN_DEPTH }}" = "standard" ]; then
            CLONE_DEPTH=10
          fi
          
          echo "üì• Cloning with depth: $CLONE_DEPTH"
          git clone --depth=$CLONE_DEPTH "$REPO_URL" "$REPO_DIR"
          
          if [ ! -d "$REPO_DIR" ]; then
            echo "‚ùå Failed to clone repository"
            exit 1
          fi
          
          cd "$REPO_DIR"
          
          # Count files (excluding .git directory)
          FILE_COUNT=$(find . -type f -not -path './.git/*' | wc -l)
          echo "FILES_SCANNED=$FILE_COUNT" >> $GITHUB_ENV
          
          echo "‚úÖ Repository cloned: $FILE_COUNT files"
          echo "repository=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "directory=$REPO_DIR" >> $GITHUB_OUTPUT
          echo "files-count=$FILE_COUNT" >> $GITHUB_OUTPUT

      - name: üîß Install Security Tools
        id: install-tools
        run: |
          echo "üì¶ Installing security scanning tools..."
          
          # Update package list
          sudo apt-get update -qq
          
          # Install Trivy
          echo "Installing Trivy..."
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release curl
          
          # Add Trivy repository
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo gpg --dearmor -o /usr/share/keyrings/trivy.gpg
          echo "deb [signed-by=/usr/share/keyrings/trivy.gpg] https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update -qq
          sudo apt-get install -y trivy
          
          # Install Node.js and Snyk
          echo "Installing Node.js and Snyk..."
          curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
          sudo apt-get install -y nodejs
          
          # Install Snyk globally
          sudo npm install -g snyk@latest
          
          # Verify installations
          echo "üîç Verifying installations..."
          trivy --version
          snyk --version
          node --version
          npm --version
          
          echo "‚úÖ Security tools installed successfully"

      - name: üîê Configure Snyk Authentication
        if: ${{ env.SCAN_DEPTH == 'deep' || env.SCAN_DEPTH == 'standard' }}
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          if [ -n "$SNYK_TOKEN" ]; then
            snyk auth "$SNYK_TOKEN"
            echo "‚úÖ Snyk authenticated"
          else
            echo "‚ö†Ô∏è SNYK_TOKEN not provided - some scans will be limited"
          fi

      - name: üîç Filesystem Security Scan
        id: trivy-fs
        continue-on-error: true
        run: |
          echo "üîç Running Trivy filesystem scan..."
          cd "${{ env.REPO_DIR }}"
          
          # Ensure output directory exists
          mkdir -p ../scan-results
          
          # Trivy filesystem scan with JSON output
          trivy fs . \
            --format json \
            --output ../scan-results/trivy-filesystem.json \
            --severity CRITICAL,HIGH,MEDIUM,LOW \
            --timeout 10m \
            --quiet \
            --exit-code 0 || {
              echo "‚ö†Ô∏è Trivy filesystem scan had issues, but continuing..."
              echo '{"Results": []}' > ../scan-results/trivy-filesystem.json
            }
          
          # Also create human-readable output
          trivy fs . \
            --format table \
            --output ../scan-results/trivy-filesystem.txt \
            --severity CRITICAL,HIGH,MEDIUM,LOW \
            --timeout 10m \
            --quiet \
            --exit-code 0 || echo "‚ö†Ô∏è Trivy table output had issues"
          
          echo "‚úÖ Filesystem scan completed"

      - name: üîê Secret Detection
        id: trivy-secrets
        continue-on-error: true
        run: |
          echo "üîê Scanning for secrets..."
          cd "${{ env.REPO_DIR }}"
          
          trivy fs . \
            --scanners secret \
            --format json \
            --output ../scan-results/trivy-secrets.json \
            --timeout 5m \
            --quiet \
            --exit-code 0 || {
              echo "‚ö†Ô∏è Secret scan had issues, but continuing..."
              echo '{"Results": []}' > ../scan-results/trivy-secrets.json
            }
          
          trivy fs . \
            --scanners secret \
            --format table \
            --output ../scan-results/trivy-secrets.txt \
            --timeout 5m \
            --quiet \
            --exit-code 0 || echo "‚ö†Ô∏è Secret scan table output had issues"
          
          echo "‚úÖ Secret detection completed"

      - name: ‚öôÔ∏è Configuration Security Scan
        id: trivy-config
        continue-on-error: true
        run: |
          echo "‚öôÔ∏è Scanning configuration files..."
          cd "${{ env.REPO_DIR }}"
          
          trivy fs . \
            --scanners config \
            --format json \
            --output ../scan-results/trivy-config.json \
            --timeout 5m \
            --quiet \
            --exit-code 0 || {
              echo "‚ö†Ô∏è Config scan had issues, but continuing..."
              echo '{"Results": []}' > ../scan-results/trivy-config.json
            }
          
          trivy fs . \
            --scanners config \
            --format table \
            --output ../scan-results/trivy-config.txt \
            --timeout 5m \
            --quiet \
            --exit-code 0 || echo "‚ö†Ô∏è Config scan table output had issues"
          
          echo "‚úÖ Configuration scan completed"

      - name: üì¶ Dependency Security Scan
        id: snyk-dependencies
        if: env.SKIP_SNYK != 'true'
        continue-on-error: true
        run: |
          echo "üì¶ Scanning dependencies with Snyk..."
          cd "${{ env.REPO_DIR }}"
          
          # Create empty results file in case Snyk fails
          echo '{"vulnerabilities": []}' > ../scan-results/snyk-dependencies.json
          
          # Snyk test with JSON output
          snyk test \
            --json \
            --all-projects \
            --detection-depth=3 \
            --severity-threshold=low > ../scan-results/snyk-dependencies.json 2>/dev/null || {
              echo "‚ö†Ô∏è Snyk scan completed with findings or errors"
              # If Snyk fails, ensure we have a valid JSON structure
              if [ ! -s ../scan-results/snyk-dependencies.json ]; then
                echo '{"vulnerabilities": []}' > ../scan-results/snyk-dependencies.json
              fi
            }
          
          # Also create human-readable output
          snyk test \
            --all-projects \
            --detection-depth=3 \
            --severity-threshold=low > ../scan-results/snyk-dependencies.txt 2>/dev/null || echo "‚ö†Ô∏è Snyk human-readable output failed"
          
          echo "‚úÖ Dependency scan completed"

      - name: üìä Process and Aggregate Results
        id: process-results
        run: |
          echo "üìä Processing scan results..."
          cd scan-results
          
          # Initialize counters
          CRITICAL=0
          HIGH=0
          MEDIUM=0
          LOW=0
          TOTAL=0
          
          # Create Python script for parsing results with detailed vulnerabilities
          cat > parse_results.py << 'EOF'
          import json
          import sys
          import os
          
          def parse_trivy_results(filename, scan_type="filesystem"):
              """Parse Trivy results and extract detailed vulnerability information"""
              counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
              vulnerabilities = []
              
              try:
                  if not os.path.exists(filename) or os.path.getsize(filename) == 0:
                      print(f"File {filename} is empty or does not exist")
                      return counts, vulnerabilities
                      
                  with open(filename, 'r') as f:
                      data = json.load(f)
                  
                  if isinstance(data, dict) and 'Results' in data:
                      for result in data['Results']:
                          target = result.get('Target', 'Unknown')
                          
                          if 'Vulnerabilities' in result and result['Vulnerabilities']:
                              for vuln in result['Vulnerabilities']:
                                  severity = vuln.get('Severity', '').lower()
                                  if severity in counts:
                                      counts[severity] += 1
                                      
                                      # Extract detailed vulnerability info
                                      vulnerability_detail = {
                                          'id': vuln.get('VulnerabilityID', 'N/A'),
                                          'title': vuln.get('Title', 'No title'),
                                          'description': (vuln.get('Description', 'No description')[:200] + '...') if len(vuln.get('Description', '')) > 200 else vuln.get('Description', 'No description'),
                                          'severity': severity.upper(),
                                          'package': vuln.get('PkgName', 'Unknown'),
                                          'installed_version': vuln.get('InstalledVersion', 'Unknown'),
                                          'fixed_version': vuln.get('FixedVersion', 'Not available'),
                                          'target': target,
                                          'source': 'Trivy',
                                          'scan_type': scan_type,
                                          'references': vuln.get('References', [])[:3]  # Limite √† 3 r√©f√©rences
                                      }
                                      
                                      vulnerabilities.append(vulnerability_detail)
                  
                  print(f"Parsed {filename}: {counts} - {len(vulnerabilities)} detailed vulnerabilities")
                  
              except Exception as e:
                  print(f"Error parsing {filename}: {e}")
              
              return counts, vulnerabilities
          
          def parse_snyk_results(filename):
              """Parse Snyk results and extract detailed vulnerability information"""
              counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
              vulnerabilities = []
              
              try:
                  if not os.path.exists(filename) or os.path.getsize(filename) == 0:
                      print(f"File {filename} is empty or does not exist")
                      return counts, vulnerabilities
                      
                  with open(filename, 'r') as f:
                      data = json.load(f)
                  
                  if isinstance(data, dict):
                      if 'vulnerabilities' in data:
                          for vuln in data['vulnerabilities']:
                              severity = vuln.get('severity', '').lower()
                              if severity in counts:
                                  counts[severity] += 1
                                  
                                  # Extract detailed vulnerability info
                                  vulnerability_detail = {
                                      'id': vuln.get('id', 'N/A'),
                                      'title': vuln.get('title', 'No title'),
                                      'description': (vuln.get('description', 'No description')[:200] + '...') if len(vuln.get('description', '')) > 200 else vuln.get('description', 'No description'),
                                      'severity': severity.upper(),
                                      'package': vuln.get('packageName', 'Unknown'),
                                      'installed_version': vuln.get('version', 'Unknown'),
                                      'fixed_version': ', '.join(vuln.get('fixedIn', [])) if vuln.get('fixedIn') else 'Not available',
                                      'target': vuln.get('from', ['Unknown'])[0] if vuln.get('from') else 'Unknown',
                                      'source': 'Snyk',
                                      'scan_type': 'dependency',
                                      'references': [vuln.get('url')] if vuln.get('url') else []
                                  }
                                  
                                  vulnerabilities.append(vulnerability_detail)
                                  
                      elif 'error' in data:
                          print(f"Snyk error: {data['error']}")
                  
                  print(f"Parsed {filename}: {counts} - {len(vulnerabilities)} detailed vulnerabilities")
                  
              except Exception as e:
                  print(f"Error parsing {filename}: {e}")
              
              return counts, vulnerabilities
          
          # Parse all result files
          total_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
          all_vulnerabilities = []
          
          # Parse Trivy results
          trivy_files = [
              ('trivy-filesystem.json', 'filesystem'),
              ('trivy-secrets.json', 'secrets'), 
              ('trivy-config.json', 'configuration')
          ]
          
          for filename, scan_type in trivy_files:
              counts, vulns = parse_trivy_results(filename, scan_type)
              for severity in total_counts:
                  total_counts[severity] += counts[severity]
              all_vulnerabilities.extend(vulns)
          
          # Parse Snyk results
          snyk_counts, snyk_vulns = parse_snyk_results('snyk-dependencies.json')
          for severity in total_counts:
              total_counts[severity] += snyk_counts[severity]
          all_vulnerabilities.extend(snyk_vulns)
          
          # Sort vulnerabilities by severity (critical first)
          severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
          all_vulnerabilities.sort(key=lambda x: severity_order.get(x['severity'], 4))
          
          # Output results
          total = sum(total_counts.values())
          print(f"CRITICAL={total_counts['critical']}")
          print(f"HIGH={total_counts['high']}")
          print(f"MEDIUM={total_counts['medium']}")
          print(f"LOW={total_counts['low']}")
          print(f"TOTAL={total}")
          print(f"DETAILED_VULNERABILITIES={len(all_vulnerabilities)}")
          
          # Save to environment file
          with open(os.environ.get('GITHUB_ENV', '/dev/null'), 'a') as f:
              f.write(f"CRITICAL_COUNT={total_counts['critical']}\n")
              f.write(f"HIGH_COUNT={total_counts['high']}\n")
              f.write(f"MEDIUM_COUNT={total_counts['medium']}\n")
              f.write(f"LOW_COUNT={total_counts['low']}\n")
              f.write(f"TOTAL_VULNERABILITIES={total}\n")
          
          # Save detailed vulnerabilities to JSON file
          with open('detailed-vulnerabilities.json', 'w') as f:
              json.dump(all_vulnerabilities, f, indent=2)
          
          print(f"üíæ Saved {len(all_vulnerabilities)} detailed vulnerabilities to detailed-vulnerabilities.json")
          EOF
          
          # Run Python script
          python3 parse_results.py
          
          # Get the results from environment variables
          CRITICAL=${CRITICAL_COUNT:-0}
          HIGH=${HIGH_COUNT:-0}
          MEDIUM=${MEDIUM_COUNT:-0}
          LOW=${LOW_COUNT:-0}
          TOTAL=${TOTAL_VULNERABILITIES:-0}
          
          # Set outputs
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "medium=$MEDIUM" >> $GITHUB_OUTPUT
          echo "low=$LOW" >> $GITHUB_OUTPUT
          echo "total-vulnerabilities=$TOTAL" >> $GITHUB_OUTPUT
          
          # Create summary JSON
          cat > scan-summary.json << EOF
          {
            "scan_id": "${{ env.SCAN_ID }}",
            "repository": "${{ env.REPO_NAME }}",
            "scan_timestamp": "${{ env.SCAN_TIMESTAMP }}",
            "files_scanned": ${{ env.FILES_SCANNED }},
            "vulnerabilities": {
              "critical": $CRITICAL,
              "high": $HIGH,
              "medium": $MEDIUM,
              "low": $LOW,
              "total": $TOTAL
            },
            "scan_depth": "${{ env.SCAN_DEPTH }}",
            "tools_used": ["trivy", "snyk"]
          }
          EOF
          
          echo "üìä Results Summary:"
          echo "  üî¥ Critical: $CRITICAL"
          echo "  üü† High: $HIGH"  
          echo "  üü° Medium: $MEDIUM"
          echo "  üü¢ Low: $LOW"
          echo "  üìä Total: $TOTAL vulnerabilities"
          echo "  üìÅ Files scanned: ${{ env.FILES_SCANNED }}"
          
          # Show count of detailed vulnerabilities found
          if [ -f "detailed-vulnerabilities.json" ]; then
            DETAILED_COUNT=$(python3 -c "import json; print(len(json.load(open('detailed-vulnerabilities.json'))))" 2>/dev/null || echo "0")
            echo "  üìã Detailed vulnerabilities: $DETAILED_COUNT"
          fi
          
      - name: üì§ Send Results to Backend
        id: send-results
        if: always()
        run: |
          echo "üì§ Sending results to callback URL..."
              
          # Calculate scan duration
          SCAN_END_TIME=$(date +%s)
          DURATION=$((SCAN_END_TIME - SCAN_START_TIME))
           
          # Determine final status
          FINAL_STATUS="completed"
          if [ "${{ job.status }}" = "failure" ] || [ "${{ job.status }}" = "cancelled" ]; then
            FINAL_STATUS="failed"
          fi
              
          # Get vulnerability counts (with defaults)
          CRITICAL_COUNT=${CRITICAL_COUNT:-0}
          HIGH_COUNT=${HIGH_COUNT:-0}
          MEDIUM_COUNT=${MEDIUM_COUNT:-0}
          LOW_COUNT=${LOW_COUNT:-0}
          TOTAL_VULNERABILITIES=${TOTAL_VULNERABILITIES:-0}
             
          # Read detailed vulnerabilities if file exists
          DETAILED_VULNS="[]"
          if [ -f "scan-results/detailed-vulnerabilities.json" ]; then
            DETAILED_VULNS=$(cat scan-results/detailed-vulnerabilities.json | jq -c '.')
            echo "üìã Found $(echo "$DETAILED_VULNS" | jq length) detailed vulnerabilities"
          elif [ -f "detailed-vulnerabilities.json" ]; then
            DETAILED_VULNS=$(cat detailed-vulnerabilities.json | jq -c '.')
            echo "üìã Found $(echo "$DETAILED_VULNS" | jq length) detailed vulnerabilities"
          fi
              
          # Create callback payload with detailed vulnerabilities using jq
          jq -n \
            --arg scan_id "${{ env.SCAN_ID }}" \
            --arg status "$FINAL_STATUS" \
            --arg repository "${{ env.REPO_NAME }}" \
            --arg github_url "${{ env.TARGET_REPO }}" \
            --argjson duration "$DURATION" \
            --argjson files_scanned "${{ env.FILES_SCANNED }}" \
            --arg start_time "${{ env.SCAN_TIMESTAMP }}" \
            --arg completed_at "$(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
            --argjson critical "$CRITICAL_COUNT" \
            --argjson high "$HIGH_COUNT" \
            --argjson medium "$MEDIUM_COUNT" \
            --argjson low "$LOW_COUNT" \
            --argjson total "$TOTAL_VULNERABILITIES" \
            --arg scan_timestamp "${{ env.SCAN_TIMESTAMP }}" \
            --arg scan_depth "${{ env.SCAN_DEPTH }}" \
            --argjson detailed_vulnerabilities "$DETAILED_VULNS" \
            '{
              scan_id: $scan_id,
              status: $status,
              repository: $repository,
              github_url: $github_url,
              duration: $duration,
              files_scanned: $files_scanned,
              start_time: $start_time,
              completed_at: $completed_at,
              results: {
                critical: $critical,
                high: $high,
                medium: $medium,
                low: $low,
                total: $total,
                scan_timestamp: $scan_timestamp,
                scan_depth: $scan_depth,
                tools_used: ["trivy", "snyk"],
                detailed_vulnerabilities: $detailed_vulnerabilities
              }
            }' > callback-payload.json
              
          echo "üìã Callback payload created with $(echo "$DETAILED_VULNS" | jq -r 'length') detailed vulnerabilities"
              
          # Show summary of payload (without showing full detailed vulnerabilities to avoid log spam)
          echo "üìã Payload summary:"
          cat callback-payload.json | jq 'del(.results.detailed_vulnerabilities) + {detailed_vulnerabilities_count: (.results.detailed_vulnerabilities | length)}'
              
          # Validate JSON before sending
          if ! jq empty callback-payload.json 2>/dev/null; then
            echo "‚ùå Generated JSON is invalid!"
            cat callback-payload.json | head -20
            exit 1
          fi
              
          # Send to callback URL with retries
          CALLBACK_SUCCESS=false
          for attempt in 1 2 3; do
            echo "üìû Attempt $attempt: Sending to ${{ env.CALLBACK_URL }}"
            
            HTTP_STATUS=$(curl -s -o callback-response.json -w "%{http_code}" \
              -X POST \
              -H "Content-Type: application/json" \
              -H "User-Agent: GitHub-Actions-Security-Scanner/1.0" \
              -H "Accept: application/json" \
              --max-time 60 \
              --retry 0 \
              -d @callback-payload.json \
              "${{ env.CALLBACK_URL }}")
            
            echo "Response status: $HTTP_STATUS"
            
            if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ] || [ "$HTTP_STATUS" = "202" ]; then
              echo "‚úÖ Callback successful!"
              CALLBACK_SUCCESS=true
              if [ -f callback-response.json ]; then
                echo "Response body:"
                cat callback-response.json
              fi
              break
            else
              echo "‚ö†Ô∏è Callback failed with status $HTTP_STATUS"
              if [ -f callback-response.json ]; then
                echo "Response body:"
                cat callback-response.json
              fi
              
              if [ $attempt -lt 3 ]; then
                echo "Retrying in 10 seconds..."
                sleep 10
              fi
            fi
          done
              
          if [ "$CALLBACK_SUCCESS" = "false" ]; then
            echo "‚ùå All callback attempts failed"
            echo "callback-status=failed" >> $GITHUB_OUTPUT
          else
            echo "callback-status=success" >> $GITHUB_OUTPUT
          fi
              
          # Set outputs
          echo "duration=$DURATION" >> $GITHUB_OUTPUT
          echo "final-status=$FINAL_STATUS" >> $GITHUB_OUTPUT
          
      - name: üìã Final Status
        id: final-status
        if: always()
        run: |
          if [ "${{ steps.send-results.outputs.callback-status }}" = "success" ]; then
            echo "‚úÖ Scan completed successfully"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Scan completed with callback errors"
            echo "status=failed" >> $GITHUB_OUTPUT
          fi
          
          echo "üìä Final Summary:"
          echo "  Repository: ${{ env.REPO_NAME }}"
          echo "  Scan ID: ${{ env.SCAN_ID }}"
          echo "  Duration: ${{ steps.send-results.outputs.duration }}s"
          echo "  Vulnerabilities: ${{ env.TOTAL_VULNERABILITIES }}"
          echo "  Files Scanned: ${{ env.FILES_SCANNED }}"
          echo "  Status: ${{ steps.send-results.outputs.final-status }}"

      - name: üìÅ Upload Scan Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results-${{ env.SCAN_ID }}
          path: |
            scan-results/
            callback-payload.json
            callback-response.json
          retention-days: 30
          if-no-files-found: warn
